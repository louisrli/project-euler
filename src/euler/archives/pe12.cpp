/* The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors? */

/* NOTES
* 1. The nth triangle number can quickly be calculated by (1 + n)/2 * n
* 2. Start at the 10th triangle number (estimate)
* 3. 
*/

using namespace std;
#include <iostream>
#include "euler.h"
#include <vector>
#include <map>

const int divisors_target = 500;
int main() {
	// for each triangle number, compute the number of divisors (prime factorization)
	long long triangle_num = 0;
	int current_divisor_count = 1;
	PrimeSieve sieve(10000000);
	for (long long i = 1; current_divisor_count < divisors_target; i++) {
		int current_divisor_count = 1;
		triangle_num += i;
		cout << "Triangle number: " << triangle_num << endl;
		long long factored_num = triangle_num;
		
		// Find the number of times that the prime factors divide into the number
		for (long long i = 0; i < sieve.primes.size() && factored_num != 1; i++)
		{
			int prime_pow = 0;
			while (factored_num % sieve.primes[i] == 0) {
				factored_num /= sieve.primes[i];
				prime_pow += 1;
			}
			
			// Update current divisor count using formula (p1 + 1) * (p2 + 1)... = divisors
			current_divisor_count *= (prime_pow + 1);
		} 
		
		// Error checking and checkmarks
		cout << "Number of divisors for " << triangle_num << " is ::: " << current_divisor_count << endl;
		if (factored_num != 1) {
			cout << "Prime factorization didn't work" << endl;
		}
	}
	
	cout << triangle_num << endl;
}