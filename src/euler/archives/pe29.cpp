/* Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    22=4, 23=8, 24=16, 25=32
    32=9, 33=27, 34=81, 35=243
    42=16, 43=64, 44=256, 45=1024
    52=25, 53=125, 54=625, 55=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
*/

/* NOTES
Each number can be represented by a distinct prime factorization
Only when a number is squared etc. can it repeat its representation
*/

using namespace std;
#include <iostream>
#include <vector>
#include <set>
#include <string>
#include <sstream>

const int kLimit = 100;

string convert_pow_to_str(int base, int exp);

int main() {
	vector<int> num_checked(kLimit + 1, false);
	set<string> num_storage;
	
	// For each a, convert a^b to a string
	for (int a = 2; a <= kLimit; a++) {
		if (num_checked[a])
			continue;
			
		// Find and store string representations of (a^n)^b as (a^nb)
		int a_new_base = a;
		int power = 1;
		do {
			for (int b = 2; b <= kLimit; b++)
				num_storage.insert(convert_pow_to_str(a, b * power));
			
			// Prepare for the next (a^n)^b
			num_checked[a_new_base] = true;
			a_new_base *= a;
			power++;
		}
		while (a_new_base <= kLimit);
	}
	cout << num_storage.size() << endl;
}

// Creates a string representation of a power
string convert_pow_to_str(int base, int exp) {
	stringstream s;
	s << base << "x" << exp;
	return s.str();
}